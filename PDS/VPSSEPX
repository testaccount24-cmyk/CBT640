         MACRO
&LABEL   VAR   &TYPE=CSECT,&LBL,&KEYWORD
         LCLA  &LEN
         AIF   ('&TYPE' EQ 'CSECT').CSECT
.*--------------------------------------------------------------------*
.*       Emit DSECT mapping Variable Name Table entry                 *
.*--------------------------------------------------------------------*
&LABEL   DSECT
VTABNAME DS    CL8              Name of variable
VTABNAML DS    H                Length of variable name
VTABLA   DS    X'4120',S        Load Address instruction to point
VTABVARL DS    H                Length of the variable value
VTABENTL EQU   *-&LABEL         Length of a table entry
         MEXIT
.*--------------------------------------------------------------------*
.*       Emit Variable Name Table entry                               *
.*--------------------------------------------------------------------*
.CSECT   ANOP
         AIF   ('&LBL' EQ '').END
&LEN     SETA  K'&KEYWORD-1
&LABEL   DC    CL8'&KEYWORD',AL2(&LEN),X'4120',S(&LBL),AL2(L'&LBL)
         MEXIT
.END     ANOP
         DC    X'FF'
         MEND
VPSSEP   TITLE 'VPS SEPARATOR PAGE ROUTINE'
***********************************************************************
*                                                                     *
* VPSSEP v1.0 - VPS Dynamic Separator Page Printer                    *
*                                                                     *
* Copyright (C) 1998-2003 Andrew J. Armstrong                         *
* a.armstrong@optusnet.com.au                                         *
* HPO Computer Services Pty Ltd                                       *
*                                                                     *
* This program is free software; you can redistribute it and/or modify*
* it under the terms of the GNU General Public License as published by*
* the Free Software Foundation; either version 2 of the License, or   *
* (at your option) any later version.                                 *
* This program is distributed in the hope that it will be useful,     *
* but WITHOUT ANY WARRANTY; without even the implied warranty of      *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *
* GNU General Public License for more details.                        *
* You should have received a copy of the GNU General Public License   *
* along with this program; if not, write to the Free Software         *
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307*
*                                                                     *
***********************************************************************
***********************************************************************
**                                                                   **
** NAME     - VPSSEP                                                 **
**                                                                   **
** TITLE    - VPS SEPARATOR PAGE EXIT                                **
**                                                                   **
** FUNCTION - This exit prints separator pages.                      **
**                                                                   **
**            The separator page is retrieved from a member in a     **
**            partitioned dataset identified by the SEPAR DD in the  **
**            VPS started task JCL.  As the exit scans the member it **
**            will substitute any variables (jobname, userid etc)    **
**            with their current values before sending the resulting **
**            datastream to the printer.                             **
**                                                                   **
**            The member name is specified on the DEVTYPE=member     **
**            printer definition statement.                          **
**                                                                   **
**            For PCL and Postscript printers you should specify     **
**            DEVTYPE=member.  The specified member will be read,    **
**            scanned for variables and sent to the printer.         **
**                                                                   **
**            For other printers you should specify DEVTYPE=LINEMODE.**
**            This will result in a separator page being printed in  **
**            block letters similar to the JES separator page.       **
**                                                                   **
**            To suppress printing a separator page, you should      **
**            specify DEVTYPE= or not code DEVTYPE at all.           **
**                                                                   **
**            The format of the separator page member is defined in  **
**            the SYNTAX section below.                              **
**                                                                   **
**            Instructions on how to create a separator page member  **
**            are in the NOTES section below.                        **
**                                                                   **
**                                                                   **
** NOTES    - 1.  HOW TO CREATE A SEPARATOR PAGE MEMBER              **
**                                                                   **
**                You can create the member manually using TSO/EDIT  **
**                or you can speed up the process by using the       **
**                following procedure:                               **
**                                                                   **
**                1.  Use a PC-based program such as MS Word to      **
**                    create a mock-up banner page.                  **
**                    Variables (for example, &userid) may appear in **
**                    the mock-up (see SYNTAX below for a list of    **
**                    variable names that you can use).              **
**                    The advantage of doing this is that 'what you  **
**                    see is what you get'.                          **
**                                                                   **
**                                                                   **
**                2.  Select a PCL printer driver (for the printer   **
**                    type on which the separator page is to be      **
**                    printed) and print the mock-up to a file.      **
**                                                                   **
**                                                                   **
**                3.  Upload the file to a mainframe partitioned     **
**                    dataset called your.separ.cntl into a member   **
**                    name of your choice.  Use a BINARY transfer    **
**                    (that is, no ASCII to EBCDIC translation).     **
**                    If using IND$FILE, ensure that ASCII and CRLF  **
**                    options are NOT specified.  If using TCP/IP    **
**                    FTP, specify BINARY before the GET or PUT.     **
**                    your.separ.cntl must be RECFM VB and it should **
**                    be LRECL 256.  Although bigger LRECLs can be   **
**                    specified, the ISPF editor can easily run out  **
**                    of memory if the LRECL is too big.             **
**                                                                   **
**                4.  Run the Rexx proc called VPSSEP, specifying    **
**                    the input member name and, optionally, the     **
**                    output member name.  If you dont specify the   **
**                    output member name then the default name is    **
**                    the input member name with a '$' suffix.       **
**                                                                   **
**                    For example: TSO VPSSEP HPLJ4 HPLJ4$           **
**                                                                   **
**                5.  Check that the output member looks OK - there  **
**                    is always room to optimise the output from     **
**                    the PCL print driver.  The following section   **
**                    describes the syntax of the output file (ie    **
**                    this file).                                    **
**                    In particular, check that all of the variable  **
**                    names (for example, &jobname) are not broken   **
**                    across lines.  The PCL printer driver treats   **
**                    these variable names as text and tries to kern **
**                    the letters.  The result is that you may see   **
**                    '&jobna', followed by a PCL command to adjust  **
**                    the current cursor position, and then 'me',    **
**                    instead of just '&jobname'.                    **
**                                                                   **
**                6.  Now that you have a clean editable version of  **
**                    the binary separator page, you can delete the  **
**                    binary version.  The VPS separator page exit   **
**                    will be reading the editable version each time **
**                    a separator page is to be printed.             **
**                                                                   **
**            2.  To get VPS to print this separator page for a      **
**                particular printer, specify the following in that  **
**                printer's printer definition member:               **
**                                                                   **
**                SEPAR=(S,VPSSEP,...)                               **
**                DEVTYPE=membername                                 **
**                                                                   **
**                Where...                                           **
**                                                                   **
**                  SEPAR specifies the name of the VPS separator    **
**                      page exit.                                   **
**                                                                   **
**                  DEVTYPE specifies the name of a member in        **
**                      your.separ.cntl which contains the PCL       **
**                      definition of the separator page for this    **
**                      printer (different PCL printer types may     **
**                      need to have different PCL data streams sent **
**                      to them).  Omitting DEVTYPE causes no        **
**                      separator pages to be printed.  Specifying   **
**                      a member which does not exist will cause VPS **
**                      to place the printer into EDRAINED status.   **
**                      Specifiying DEVTYPE=LINEMODE causes the JES  **
**                      block letter separators to be printed.       **
**                      The DEVTYPE keyword is not used by any VPS   **
**                      system code - it is soley for use by user    **
**                      exits.                                       **
**                                                                   **
**            3.  You must also have the your.separ.cntl dataset     **
**                allocated in the VPS started task with a DD name   **
**                of SEPAR.  The separator page exit (VPSSEP) reads  **
**                from the file allocated to the SEPAR DD name and   **
**                expects it to be a PDS with RECFM=VB.  For example,**
**                                                                   **
**                //SEPAR DD DISP=SHR,DSN=your.separ.cntl            **
**                                                                   **
**                                                                   **
**                                                                   **
** SYNTAX   - The syntax of the file created by the VPSSEP Rexx      **
**            procedure and read by the VPSSEP separator page exit   **
**            is as follows:                                         **
**                                                                   **
**            Column 1 is a record type indicator.                   **
**            Columns 2 to the maximum record length contain data    **
**            specific to the record type.                           **
**                                                                   **
**            Col1 Usage                                             **
**            ---- ------------------------------------------------  **
**             *   Signifies a comment line.  The entire record is   **
**                 ignored.                                          **
**                                                                   **
**             B   Signifies that the following text is binary data  **
**                 that is to be appended to the data stream to be   **
**                 sent to the printer.  This data is appended 'asis'**
**                 ...it is not translated to ASCII.  Binary data is **
**                 typically used to print a graphic (for example,   **
**                 a company logo).                                  **
**                                                                   **
**             C   Signifies that the following text is binary data  **
**                 and is to be appended to the data stream to be    **
**                 sent to the printer 'as is' AFTER REMOVING THE    **
**                 TRAILING X'FF'.  Apparently, MVS removes trailing **
**                 blanks (X'40' code points) from each record before**
**                 it is written to a RECFM=V partitioned dataset    **
**                 member.  The C record is identical to the B       **
**                 record except that the C record has X'FF' appended**
**                 before it is written.  So, if a block of binary   **
**                 data would end in X'40', a C record is written,   **
**                 else a B record is written.                       **
**                                                                   **
**             E   Signifies that the following text is a PCL escape **
**                 sequence (excluding the escape character). The    **
**                 remaining text up to, but not including, the      **
**                 first blank is translated to ASCII and appended   **
**                 to the PCL escape character (X'1B').              **
**                 The resulting escape sequence is appended to the  **
**                 data stream to be sent to the printer.            **
**                 Any characters after (and including) the first    **
**                 blank are treated as comments and are ignored.    **
**                                                                   **
**             &   Signifies that the following text is the name of  **
**                 a variable.                                       **
**                 The current content of the variable is translated **
**                 to ASCII and appended to the data stream. The     **
**                 first blank after the & indicates the end of the  **
**                 variable name.                                    **
**                 Any characters after the first blank are treated  **
**                 as comments and are ignored.                      **
**                                                                   **
**             Any other character in column 1 (including a blank)   **
**             is the delimiter for the following text.  The text    **
**             bounded by these delimiters is translated into ASCII  **
**             and appended to the data stream to be sent to the     **
**             printer.  Hence, if the text consists of a single     **
**             word, then column 1 will be a blank and the word will **
**             be terminated by the next blank.                      **
**             For example,                                          **
**                                                                   **
**             Column 1                                              **
**             |                                                     **
**             V                                                     **
**              text             ...comment...                       **
**                                                                   **
**             If the text contains embedded blanks, then column 1   **
**             will be a single quote (') and the text will be term- **
**             inated by another single quote.  For example:         **
**                                                                   **
**             'text containing embedded blanks' ...comment...       **
**                                                                   **
**             Any other delimiter may be chosen, so long as the     **
**             delimiter character itself does not appear in the     **
**             text.  The following examples are equivalent:         **
**                                                                   **
**              text             ...comment...                       **
**             'text'            ...comment...                       **
**             "text"            ...comment...                       **
**             /text/            ...comment...                       **
**             (text(            ...comment...                       **
**                                                                   **
**                                                                   **
** SYNTAX                                                            **
** NOTES    - 1.  Lines beginning with two blanks are ignored        **
**                because blank is the delimiter and there is no     **
**                text between the first and second blanks.          **
**                                                                   **
**            2.  Variable names are as follows:                     **
**                                                                   **
**                &BANNER   Contains either START or END or CONT     **
**                &JOBID    Job number (eg JOBnnnnn or STCnnnnn)     **
**                &JOBNAME  Job name                                 **
**                &PRTMEMB  Printer VPS definition member name       **
**                &PRTNAME  Printer name (luname, IP addr or hostname**
**                &REPCLASS Report sysout class                      **
**                &REPCDATE Report creation date (yyyy/mm/dd hh:mm:ss**
**                &REPDEST  Report destination name                  **
**                &REPPDATE Report print date (yyyy/mm/dd hh:mm:ss)  **
**                &USERID   User user id                             **
**                &USERNAME User full name (lastname, firstname)     **
**                &OUTADDR1 Address line 1                           **
**                &OUTADDR2 Address line 2                           **
**                &OUTADDR3 Address line 3                           **
**                &OUTADDR4 Address line 4                           **
**                &OUTBUILD Building                                 **
**                &OUTCLASS Class                                    **
**                &OUTDEPT  Department                               **
**                &OUTDEST  Destination                              **
**                &OUTJESDS JES Dataset type (ALL,JCL,LOG or MSG)    **
**                &OUTGROUP Output group                             **
**                &OUTNAME  Name                                     **
**                &OUTROOM  Room                                     **
**                &OUTTITLE Title                                    **
**                &OUTWTR   Writer name                      20000211**
**                &FLASH    Flash overlay name               20010720**
**                                                                   **
**                The names are case-insensitive.  For example, the  **
**                following names are all equivalent:                **
**                                                                   **
**                     &USERNAME                                     **
**                     &username                                     **
**                     &UserName                                     **
**                                                                   **
**                Other variables can be defined - but this          **
**                requires changing the VPSSEP separator page exit   **
**                and the VPSSEP Rexx procedure as well.             **
**                                                                   **
**            3.  Substrings of the variables can be specified       **
**                with the following syntax:                         **
**                                                                   **
**                &varname(firstchar,numchars)                       **
**                                                                   **
**                For example, &REPCDATE(1,4) returns the first four **
**                characters of the report creation date (ie yyyy).  **
**                                                                   **
**                If numchars is omitted then the remainder of the   **
**                variable starting with firstchar is printed.       **
**                                                                   **
**                The syntax does not enforce the use of '(' or ','. **
**                Any non-blank non-digit may be used to delimit the **
**                firstchar and numchars values.  Parsing for values **
**                stops at the first blank encountered.              **
**                                                                   **
**                For example, the following are all equivalent:     **
**                                                                   **
**                   &REPCDATE(1,4)                                  **
**                   &REPCDATE=1:4                                   **
**                   &REPCDATE-FROM-POSITION-1-FOR-4-CHARACTERS      **
**                                                                   **
**                This feature is useful when you only want a fixed  **
**                number of characters printed for a variable.  The  **
**                &username variable is a good candidate for trunc-  **
**                ation since user names can be quite long.  To      **
**                truncate the &username to, say, 20 characters, you **
**                should specify: &username(1,20)                    **
**                                                                   **
**                                                                   **
** ON ENTRY - R1  - Parameter list address                           **
**            R14 - Return address                                   **
**            R15 - Entry point address                              **
**                                                                   **
** ON EXIT  -                                                        **
**                                                                   **
** AUTHOR   - Andrew J. Armstrong <a.armstrong@optusnet.com.au>      **
**                                                                   **
** HISTORY - Date     By  Reason (most recent at the top please)     **
**           -------- --- -----------------------------------------  **
**           20030613 AJA Packaged for distribution via cbttape.org  **
**           20030124 AJA Load unsigned max line length safely.      **
**           20010810 AJA Added DCBE to allow a 31-bit EODAD to be   **
**                        used. Otherwise reading until end-of-file  **
**                        will cause a S0C4 (the workaround was to   **
**                        stop reading when '//' was read).          **
**           20010720 AJA Added FLASH variable and let DD writer name**
**                        override the OUTPUT writer name.           **
**           20000211 AJA Added OUTWTR variable and changed code to  **
**                        use the new immediate/relative instructions.*
**           19981011 AJA Allowed for ISPF editor hack: it will not  **
**                        write an 8-byte record to a RECFM=V dataset.*
**           19980409 AJA Enhanced to support Postscript printers.   **
**                        Now, a separator will be sent to the       **
**                        printer as long as DEVTYPE=member is       **
**                        specified...regardless of whether the      **
**                        printer supports PCL or not.  Also, if a   **
**                        separator is required for a line-mode      **
**                        printer (ie no PCL or Postscript support)  **
**                        then specify DEVTYPE=LINEMODE.             **
**           19971210 AJA Initial version.                           **
**                                                                   **
***********************************************************************
         EJECT
*---------------------------------------------------------------------*
*                                                                     *
*   REGISTER USAGE:                                                   *
*                                                                     *
*      ON ENTRY:                                                      *
*         R0 ==>  REQUEST CODE.                                       *
*                 00 - START-JOB SEPARATOR PAGE REQUEST               *
*                 04 - END-JOB   SEPARATOR PAGE REQUEST               *
*                 08 - CLEAN-UP  REQUEST                              *
*                                                                     *
*         R1 ==>  ADDRESS OF PARAMETER LIST.                          *
*        R13 ==>  ADDRESS OF CALLERS SAVEAREA.                        *
*        R14 ==>  RETURN ADDRESS.                                     *
*        R15 ==>  ENTRY  ADDRESS.                                     *
*                                                                     *
*      DURING EXECUTION:                                              *
*         R0 ==>  WORK REG.                                           *
*         R1 ==>  WORK REG.                                           *
*         R2 ==>  WORK REG.                                           *
*         R3 ==>  WORK REG.                                           *
*         R4 ==>  POINTER TO SYSTEM ATTRIBUTES.                       *
*         R5 ==>  POINTER TO PRINTER ATTRIBUTES.                      *
*         R6 ==>  POINTER TO JOB STATISTICS.                          *
*         R7 ==>  POINTER TO USER AREA.                               *
*         R8 ==>  POINTER TO LINE WORK AREA.                          *
*         R9 ==>  POINTER TO SEPARATOR INFO AREA.                     *
*        R10 ==>  WORK REG.
*    R11-R12 ==>  VPSSEP BASE REGISTERS.
*        R13 ==>  ADDRESS OF WORK AREA DSECT (INCLUDES SAVE AREA).    *
*        R14 ==>  WORK REG.                                           *
*        R15 ==>  WORK REG.                                           *
*                                                                     *
*      ON EXIT:                                                       *
*         ALL REGISTERS WILL BE RESTORED TO ENTRY CONDITIONS, EXCEPT  *
*      R15, WHICH WILL CONTAIN THE RETURN CODE.                       *
*                                                                     *
*---------------------------------------------------------------------*
         EJECT
*---------------------------------------------------------------------*
*                                                                     *
*   PARAMETER LIST FORMAT:                                            *
*                                                                     *
*      A(SYSTEM ATTRIBUTES)  - MAPPING MACRO: VPSSSYAT                *
*      A(USER WORKAREA)      - MAPPING MACRO: N/A                     *
*      A(PRINTER ATTRIBUTES) - MAPPING MACRO: VPSSPRAT                *
*      A(JOB STATISTICS)     - MAPPING MACRO: VPSSJSTA                *
*      A(SEPARATOR WORKAREA) - MAPPING MACRO: N/A                     *
*      A(LINE WORKAREA)      - MAPPING MACRO: VPSSLINE                *
*      A(SEPARATOR INFO)     - MAPPING MACRO: VPSSSEPI                *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*   RETURN CODES:                                                     *
*                                                                     *
*     00 - SEPARATOR LINE AVAILABLE TO PRINT & CALL US AGAIN          *
*     04 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *
*     08 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *
*     12 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *
*     16 - DISASTROUS ERROR, NOTHING TO PRINT & DON'T CALL US AGAIN   *
*                                                                     *
*---------------------------------------------------------------------*
         EJECT
***********************************************************************
*                                                                     *
*                         R E G I S T E R S                           *
*                                                                     *
***********************************************************************

R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
***********************************************************************
*                                                                     *
*                           M A I N L I N E                           *
*                                                                     *
***********************************************************************

VPSSEP   CSECT
         GBLC  &SYSSPLV
         SPLEVEL TEST
         AIF   ('&SYSSPLV' EQ '1').UXIT000
VPSSEP   AMODE ANY
VPSSEP   RMODE ANY
.UXIT000 ANOP
         USING VPSSEP,R11,R12       ESTABLISH PROGRAM BASE
*        --------------------
         J     Start                BRANCH AROUND CONSTANTS.
         DC    CL8'VPSSEP'          Module name
         DC    CL8'&SYSDATC'        Assembly date (yyyymmdd)
         DC    CL8'&SYSTIME'        Assembly time (hh:mm)
Start    DS    0H
         STM   R14,R12,12(R13)      SAVE CALLERS REGISTERS.
         LR    R11,R15              LOAD 1ST PROGRAM BASE REGISTER.
         LA    R12,2048(,R11)       LOAD 2ND...
         LA    R12,2048(,R12)            PROGRAM BASE REGISTER.

         LR    R2,R0                SAVE SEPARATOR REQUEST CODE.

         L     R4,0(,R1)
         LM    R5,R9,8(R1)

         USING SYADSECT,R4        Map System Attributes
*        -----------------
         USING PRADSECT,R5        Map Printer Attributes
*        -----------------
         USING JSTDSECT,R6        Map Job Statistics
*        -----------------
         USING SEPUSER,R7         Map User Area
*        ----------------
         USING LINEDSCT,R8        Map Line Work Area
*        -----------------
         USING SEPDSECT,R9        Map Separator Info Area
*        -----------------
         USING WORKAREA,R10       Map Work Area (retained across calls)
*        ------------------
         USING SEPRDSCT,R13       Map Work Area (not retained)
*        ------------------
         EJECT
*---------------------------------------------------------------------*
*        Obtain a work area and clear it                              *
*---------------------------------------------------------------------*

         GETMAIN RU,LV=SEPRDSLN     ACQUIRE WORK AREA.

         ST    R1,8(,R13)           FORWARD CHAIN SAVE AREAS.
         ST    R13,4(,R1)           BACK CHAIN.
         LR    R13,R1               LOAD WORK DSECT BASE REGISTER.

         LA    R0,8(,R1)            RECEIVING FIELD FOR MVCL.
         LA    R1,SEPRDSLN-8        RECEIVING FIELD LENGTH FOR MVCL.
         SR    R14,R14              SENDING   FIELD FOR MVCL.
         SR    R15,R15              SENDING   FIELD LENGTH FOR MVCL.
         MVCL  R0,R14               INITIALIZE WORK AREA.

*---------------------------------------------------------------------*
*        Branch to appropriate routine based on the request code      *
*---------------------------------------------------------------------*

*=====================================================================*
*                                                                     *
*     00 - START-JOB SEPARATOR REQUEST                                *
*     04 - END-JOB   SEPARATOR REQUEST                                *
*     08 - CLEAN-UP  REQUEST - SOME TYPE OF ERROR HAS OCCURRED IN A   *
*                    VPS TASK. THE SEPARATOR ROUTINE SHOULD CLOSE ANY *
*                    OPEN FILES, FREE ANY ACQUIRED STORAGE, ETC.      *
*                                                                     *
*                    THIS SEPARATOR ROUTINE SIMPLY EXITS ON A         *
*                    CLEAN-UP CALL SINCE IT OPENS NO FILES OR LEAVES  *
*                    ANY STORAGE ACQUIRED ACROSS CALLS.               *
*                                                                     *
* SEPARATOR EXIT RETURN CODE (R15) MEANINGS:                          *
*                                                                     *
*     00 - SEPARATOR LINE AVAILABLE TO PRINT & CALL US AGAIN          *
*     04 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *
*     08 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *
*     12 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *
*     16 - DISASTROUS ERROR, NOTHING TO PRINT & DON'T CALL US AGAIN   *
*                                                                     *
*---------------------------------------------------------------------*

         MVC   nRetCode,=F'0'       ZERO OUT THE RETURN CODE
         ST    R2,nRequest          SAVE THE REQUEST CODE

         B     *+4(R2)              (00 = START-JOB, 04 = END-JOB).
         J     StartJob             BRANCH TO START-JOB SEPARATOR.
         J     StartJob             BRANCH TO END-JOB SEPARATOR
         J     CleanUp              BRANCH TO CLEAN-UP.
         EJECT
***********************************************************************
*                                                                     *
*              START-JOB AND END-JOB SEPARATOR PROCESSING             *
*                                                                     *
***********************************************************************

*---------------------------------------------------------------
*        Obtain storage for a workarea if not already done
*---------------------------------------------------------------

StartJob DS    0H
         L     R10,pWorkArea      -> Work area
         LTR   R10,R10              Workarea obtained already?
         JNZ   Primed               Yes, branch

         STORAGE OBTAIN,LENGTH=WORKAREA#,LOC=BELOW,ADDR=(R10)
         ST    R10,pWorkArea        Save workarea address

*---------------------------------------------------------------------*
*        Initialise work area variables                               *
*---------------------------------------------------------------------*

         ST    R5,pPRAT             -> VPSSPRAT

         LA    R0,sVars             -> Target
         LHI   R1,sVars#            L'Target
         SLR   R14,R14              -> Source (not used)
         SLR   R15,R15              L'Source (0 forces pad)
         ICM   R15,B'1000',sBlanks  Pad byte is a blank
         MVCL  R0,R14               Initialise variables to blanks

         LA    R0,sRACFWork         -> Target
         LHI   R1,L'sRACFWork       L'Target (pad in high order byte)
         SLR   R14,R14              -> Source (not used)
         SLR   R15,R15              L'Source (0 forces pad)
*                                   Pad byte is a null
         MVCL  R0,R14               Initialise variables to nulls

*---------------------------------------------------------------------*
*        Get userid                                                   *
*---------------------------------------------------------------------*

         L     R14,SEPXMA         -> XMA data from VPS exit 15
         LTR   R14,R14            Is VPS exit 15 active?
         JZ    FromJob            No, get userid from job name

         USING XMADSECT,R14
*        ------------------
         MVC   sFlsh,XMAFLASH     Get flash overlay name       20010720
         MVC   sOutW,XMAWTR       Get writer name from DD      20010720
         MVC   sUsrI,XMAJOWNR     Get user id
         L     R14,XMAORAT        -> OUTPUT card fields
         DROP  R14
*        ---------

         LTR   R14,R14            Any OUTPUT card fields?
         JZ    NoOutput           No, branch

         USING ORADSECT,R14
*        ------------------
         MVC   sOut1,ORAADDR1     Get address line 1
         MVC   sOut2,ORAADDR2     Get address line 2
         MVC   sOut3,ORAADDR3     Get address line 3
         MVC   sOut4,ORAADDR4     Get address line 4
         MVC   sOutB,ORABLDG      Get building name
         MVC   sOutC,ORACLS       Get class
         MVC   sOutO,ORADEPT      Get department name
         MVC   sOutD,ORADEST      Get destination name
         MVC   sOutJ,ORAJESDS     Get JES dataset type
         MVC   sOutG,ORAGRP       Get output group
         MVC   sOutN,ORANAME      Get user name
         MVC   sOutR,ORAROOM      Get room name
         MVC   sOutT,ORATITLE     Get output title

         CLC   sOutW,=XL8'00'     Writer specified on DD?      20010720
         JNE   NoWriter           No, jump                     20010720
         MVC   sOutW,ORAWTR       Get writer name              20000211
NoWriter DS    0H                                              20010720

         CLC   sFlsh,=XL8'00'     Flash overlay on DD?         20010720
         JNE   NoFlash            No, jump                     20010720
         MVC   sFlsh,ORAFLASH     Get flash name from OUTPUT   20010720
NoFlash  DS    0H                                              20010720

         DROP  R14
*        ---------

NoOutput DS    0H

         MVC   sRACFUsr,sUsrI     Set userid for RACF
         LHI   R14,L'sRACFUsr     Maximum userid length
         LA    R15,sRACFUsr       -> Start of userid
NextU    DS    0H
         CLI   0(R15),C' '        Found first blank in userid?
         JE    FoundU             Yes, branch
         LA    R15,1(,R15)        -> next byte in userid
         BRCT  R14,NextU          ...until end of userid
FoundU   DS    0H

         LHI   R15,L'sRACFUsr     Maximum userid length
         SR    R15,R14            Compute actual length of userid
         JNP   FromJob            ...get userid from job if length NBG

         STC   R15,cRACFLen       Set length of userid for RACF
         J     GotUser

*---------------------------------------------------------------------*
*        Get userid from job name (this is installation-specific)     *
*---------------------------------------------------------------------*

ULEN     EQU   4    <- SET THIS TO THE INSTALLATION'S USERID LENGTH

FromJob  DS    0H
         MVC   sUsrI,JSTJOBNM     Get user id from job name
         MVC   sUsrI+ULEN(L'sUsrI-ULEN),sBlanks
         MVC   sRACFUsr,JSTJOBNM  Get user id from job name
         MVI   cRACFLen,ULEN      Set user id length for SAF

*---------------------------------------------------------------------*
*        Create an ACEE for the userid                                *
*---------------------------------------------------------------------*

GotUser  DS    0H
         MVC   sVerify(sVerify#),kVerify Copy plist to workarea

         RACROUTE MF=(E,sVerify),                                      X
               REQUEST=VERIFY,                                         X
               ACEE=pACEE,        -> Accessor Control Element          X
               ENVIR=CREATE,      Create ACEE                          X
               USERID=sRACFUID,   -> AL1(len),CL(len)'userid'          X
               PASSCHK=NO,        Do not verify the users password     X
               WORKA=sRACFWork,   -> RACF workarea                     X
               RELEASE=2.4

         LTR   R15,R15            Did it work?
         JNZ   RACFDone           No, branch

*---------------------------------------------------------------------*
*        Extract the user name field from the ACEE                    *
*---------------------------------------------------------------------*

         L     R3,pACEE
         USING ACEE,R3
*        -------------
         L     R2,ACEEUNAM        ->AL1(len+1),CL(len)'user name'
         DROP  R3
*        --------
         SLR   R3,R3
         IC    R3,0(R2)           Get L'Programmer Name
         BCTR  R3,*-*
         LHI   R1,L'sUsrN         Get maximum length allowed
         CR    R3,R1              Will extracted field fit in target?
         JNL   UsrOK              Yes, branch
         LR    R1,R3              No, truncate to size of target
UsrOK    DS    0H

         BCTR  R1,*-*             -1 for EX
         LTR   R1,R1              Is length 0 or negative?
         JM    ExtrDone           Yes, don't use it

CopyUser MVC   sUsrN(*-*),1(R2)   Copy field to target
         EX    R1,CopyUser

ExtrDone DS    0H

*---------------------------------------------------------------------*
*        Issue RACROUTE to delete the ACEE just created               *
*---------------------------------------------------------------------*

         MVC   sVerify(sVerify#),kVerify Copy plist to  workarea

         RACROUTE MF=(E,sVerify),                                      X
               REQUEST=VERIFY,                                         X
               ACEE=pACEE,        -> Accessor Control Element          X
               ENVIR=DELETE,      Delete ACEE                          X
               WORKA=sRACFWork,   -> RACF workarea                     X
               RELEASE=2.4

RACFDone DS    0H

*---------------------------------------------------------------------*
*        Prime all system variables with their current values         *
*---------------------------------------------------------------------*

Prime    DS    0H
         MVC   sBann,=CL5'START'
         CLC   nRequest,=F'0'     Is this a start separator?
         JE    BannerOK           Yes, branch
         MVC   sBann,=CL5'END'
BannerOK DS    0H

         MVC   sJobI,JSTJOBID     Get job id
         MVC   sJobN,JSTJOBNM     Get job name
         MVC   sPrtM,PRAMNAME     Get printer member name

         MVC   sPrtN(8),PRATNAME  Get LU name

*----->  CLI   PRALUTYP,$PRALUT   Is this a TCP/IP printer?
*----->  JNE   NameOK             No, branch

         TM    PRADEVF4,$PRADLPD+$PRADSOK Is this a TCP/IP printer?
*                       $PRADLPD = TCP/IP Line Printer Daemon (LPD)
*                       $PRADSOK = TCP/IP Direct Sockets (port 9100)
         JZ    NameOK             No, branch

         MVC   sPrtN,PRATCPHS     Get IP address or hostname

NameOK   DS    0H
         MVC   sRepC,SEPCLASS     Get report class

*                                 Get report spooled date...
         MVC   sRepS,=C'yyyy/mm/dd hh:mm:ss day'
         MVC   sRepS+00(04),JSTORDGC+4 yyyy
         MVC   sRepS+05(02),JSTORDGC+0 mm
         MVC   sRepS+08(02),JSTORDGC+2 dd
         MVC   sRepS+11(02),JSTORTME+0 hh
         MVC   sRepS+14(02),JSTORTME+2 mm
         MVC   sRepS+17(02),JSTORTME+4 ss
         MVC   sRepS+20(03),JSTORDAY   day

         MVC   sRepD,SEPDEST      Get report destination

*                                 Get report printed date...
         MVC   sRepP,=C'yyyy/mm/dd hh:mm:ss day'
         MVC   sRepP+00(04),JSTOPDGC+4 yyyy
         MVC   sRepP+05(02),JSTOPDGC+0 mm
         MVC   sRepP+08(02),JSTOPDGC+2 dd
         MVC   sRepP+11(02),JSTOPTME+0 hh
         MVC   sRepP+14(02),JSTOPTME+2 mm
         MVC   sRepP+17(02),JSTOPTME+4 ss
         MVC   sRepP+20(03),JSTOPDAY   day

         MVC   sMember,sBlanks    Prime member name

*---------------------------------------------------------------------*
*        If this is a PCL printer, then build PCL buffer...           *
*---------------------------------------------------------------------*

         CLC   =CL8'LINEMODE',PRATDEVT Is a linemode printer?  19980409
         JE    LineMode           Yes, no page-mode separator  19980409

         XC    pPCL,pPCL          -> PCL buffer = 0

*        Was DEVTYPE keyword specified?
         CLI   PRATDEVT,0
         JE    Primed             No, dont print a PCL separator

         MVC   sDCBE(sDCBE#),kDCBE    Copy plist to work area  20010810
         MVC   sFile(sFile#),kFile    Copy plist to work area
         LA    R15,sDCBE              -> DCBE in work area     20010810
         ST    R15,sFile              Make DCB point to DCBE   20010810
         MVC   sOpen(sOpen#),kOpen    Copy plist to work area
         MVC   sClose(sClose#),kClose Copy plist to work area

*        Open partitioned dataset
         OPEN  (sFile,INPUT),MF=(E,sOpen),MODE=31
         LTR   R15,R15            Did it work?
         JNZ   CloseFile          No, branch

*        Extract member name from DEVTYPE keyword
         MVC   sMember,PRATDEVT   Copy member name from DEVTYPE field

*        find member
FindIt   DS    0H
         FIND  sFile,sMember,D
         LTR   R15,R15            Member found?
         JNZ   CloseFile          No, branch
         J     FirstBlk           Yes, read first block of records

         PUSH  USING
         USING RECORD,R5
*        ---------------
*        Get next record
Next     DS    0H
         SLR   R1,R1
         ICM   R1,B'0011',hRecLen Get length of current record
         AR    R5,R1              -> Next record in block
         C     R5,pBlockEnd       Processed last record in block?
         JL    GotRec

FirstBlk DS    0H
         READ  sDECB,SF,sFile,sBlock,MF=E
         CHECK sDECB

         LA    R5,sBlock          -> X'LLBB',XL(LL)'block data'
         SLR   R1,R1
         ICM   R1,B'0011',hBlock  Get length of block
         AR    R5,R1              -> Byte after end of block
         ST    R5,pBlockEnd       -> Save for Next pass
         LA    R5,sBlockData      -> First data record in block

*        do while not eof
*          select

GotRec   DS    0H

*---------------------------------------------------------------------*
*        Process comment records (eg * This is a comment)             *
*---------------------------------------------------------------------*

*            when col1='*' then nop
         CLC   hRecLen,=AL2(4+2)  At least 2 bytes of data?
         JL    Next               No, branch

         CLI   cRecType,C'*'      Is this a comment record?
         JE    Next               Yes, branch

*---------------------------------------------------------------------*
*        Process PCL escape sequence records (eg E*t300r)             *
*---------------------------------------------------------------------*

*            when col1='E' then do
         CLI   cRecType,C'E'      Is this a PCL ESCAPE record?
         JNE   WhenBin            No, branch

*              append x'1B'
         MVI   cRecType,X'1B'     Change 'E' to real PCL escape char
*              find first blank
         LA    R1,sRecData        -> First byte after 'E'
         SLR   R0,R0
         ICM   R0,B'0011',hRecLen L'Record (including record type)
         AHI   R0,-(4+1)          -4 for LLBB, -1 for record type

Next1    DS    0H
         CLI   0(R1),C' '         End of PCL command?
         JE    End1               Yes, branch

         TR    0(1,R1),sToASCII   Translate byte to ASCII
         LA    R1,1(,R1)          -> Next source byte
         BRCT  R0,Next1           ...until source is exhausted

End1     DS    0H
         LA    R0,sRecData        -> PCL command operands
         SR    R1,R0              L'PCL command operands

*              append remaining record
         LA    R0,1(,R1)          Length of PCL command (incl. X'1b')
         LA    R1,cRecType        -> X'1b' followed by PCL command
         BRAS  R14,Append
*            end
         J     Next



*---------------------------------------------------------------------*
*        Process binary data records (eg B...binary..data...)         *
*---------------------------------------------------------------------*

*            when col1='B' then do
WhenBin  DS    0H
         CLI   cRecType,C'B'      Is this a binary data record?
         JNE   WhenBin2           No, branch
*              append remaining record as is
         LA    R1,sRecData        -> Binary data

*                           cRecType=C'B'
*                                  |
*                         hRecLen  |sRecData
*                              |   ||
*                              --  VV
*                            C'llbbtxxxxx........xx'
*                              <----hRecLen------->
*                                   <- hRecLen-5 ->

         SLR   R0,R0
         ICM   R0,B'0011',hRecLen L'Record (including record type)
         AHI   R0,-(4+1)          -4 for LLBB, -1 for record type byte

*              If the binary data ends in a blank (x'40') then 19981110
*              ignore the blank...any data which really does   19981110
*              have a trailing blank should be represented     19981110
*              by a type 'C' record which is terminated by a   19981110
*              trailing x'FF' (see WhenBin2 below).            19981110
         LA    R14,sRecData-1     -> Binary data - 1           19981110
         ALR   R14,R0             -> Last byte of binary data  19981110
         CLI   0(R14),X'40'       Trailing blank?              19981110
         JNE   BinOK                                           19981110
         BCTR  R0,*-*             Length of binary data - 1    19981110
BinOK    DS    0H                                              19981110

*              append remaining record as is
         BRAS  R14,Append
*            end
         J     Next


*---------------------------------------------------------------------*
*        Process binary data records (eg C...binary..data...x'ff')    *
*---------------------------------------------------------------------*

*            when col1='C' then do
WhenBin2 DS    0H
         CLI   cRecType,C'C'      Is this a binary data record?
         JNE   WhenVar            No, branch
*              append remaining record as is
         LA    R1,sRecData        -> Binary data
         SLR   R0,R0
         ICM   R0,B'0011',hRecLen L'Record (including record type)
         AHI   R0,-(4+1)          -4 for LLBB, -1 for record type byte
         BCTR  R0,*-*             -1 to strip trailing x'ff'
         BRAS  R14,Append
*            end
         J     Next



*---------------------------------------------------------------------*
*        Process variable name records (eg &JobName )                 *
*---------------------------------------------------------------------*

*            when col1='&' then do
WhenVar  DS    0H
         CLI   cRecType,C'&&'     Is this a variable name record?
         JNE   Other              No, branch

*              find varname in vartab
         MVC   sVar,sRecData      Copy variable name for massaging
         OC    sVar,sBlanks       Convert it to upper case
         LA    R1,VARTAB          -> First entry in table
         USING VARTABD,R1
*        ----------------

Next3    DS    0H
         LH    R2,VTABNAML        No, get length of name from table
         EX    R2,Check3          Variable name found?
         JE    SubVar             Yes, branch
         LA    R1,VTABENTL(,R1)   -> Next entry in table
         CLI   VTABNAME,X'FF'     End of variable name table?
         JNE   Next3              No, keep looking

*              Input:  '&JUNKVARNAME Comments...'
         MVC   sVar,cRecType      Copy variable name out of harms way
         MVC   sRecData(L'sVar),sVar Now copy name back
         MVI   cRecType,C' '      Insert a leading blank delimiter
         MVI   sRecData+L'sVar,C' ' Insert a trailing blank delimiter
*              Output: ' &JUNKVARNAME Comments...'
         J     Other              ...print just '&JUNKVARNAME'
Check3   CLC   sVar(*-*),VTABNAME

*              Get current value of varname into sVar...
SubVar   DS    0H
         LA    R2,X'20'           Nominate R2 to receive address
         EX    R2,VTABLA          -> LA R2,xxx(0,y)  (current value)
         MVC   sVar,0(R2)         Copy to a work area for translation
         TR    sVar,sToASCII      Translate to ASCII
         LH    R0,VTABVARL        L'String (from table entry)
         STH   R0,hVarLen         Save for later
         LH    R2,VTABNAML        Get length of name from table again
         AHI   R2,1+1             +1, +1 to skip over '&' at front
         DROP  R1
*        --------

*              Get first number (if any) before the first blank
         LA    R1,cRecType        -> &varname(index,length) comment
         AR    R1,R2                      -> (index,length) comment
         SLR   R0,R0
         ICM   R0,B'0011',hRecLen L'Record (including record type)
         SR    R0,R2              Less L'&varname
         BRAS  R14,c2b            Is substring index present?
         JNZ   Full               No, append the full string
         STH   R2,hSubBeg         Save substring start index

*              Get next number (if any) before the first blank
         BRAS  R14,c2b            Get substring length if present
         STH   R2,hSubLen         Save substring length (or 0)

         LA    R1,sVar            -> Full string
         AH    R1,hSubBeg         -> Start of substring + 1
         BCTR  R1,*-*             -> Start of substring

         LH    R0,hSubLen         L'Substring
         LTR   R0,R0              Was a substring length supplied?
         JNZ   AppStr             Yes, append the substring

         LH    R0,hVarLen         No, compute length of remainder
         SH    R0,hSubBeg         L'remainder - 1
         AHI   R0,1               L'remainder
         J     NoTrail            Strip trailing blanks though

*                append full value
Full     DS    0H
         LH    R0,hVarLen        L'String (from table entry)
         LA    R1,sVar           -> String to append

NoTrail  DS    0H                R1->String, R0=L'String
         LR    R2,R1             ->String
         LR    R3,R0             L'String
         AR    R1,R0             -> Last byte of string + 1
NextF    DS    0H
         BCTR  R1,*-*            -> Previous byte
         CLI   0(R1),X'20'       Is it a trailing (ASCII) blank?
         JNE   FullDone          No, append string up to here
         BRCT  R3,NextF          ...until no more chars to check
         J     Next              ...string is all blank, so ignore it

FullDone DS    0H
         LR    R1,R2             -> Start of string to append
         LR    R0,R3             L'String (sans trailing blanks)

*                append substring of value
AppStr   DS    0H
         BRAS  R14,Append
*              end
*              else append varname /* for debugging */
*            end
         J     Next



*---------------------------------------------------------------------*
*        Process string records (eg 'Job Name:')                      *
*---------------------------------------------------------------------*

*            Otherwise do
Other    DS    0H
*              if length of data between the two delimiters is zero
         CLC   cRecType(1),cRecType+1 Is it a null record? eg ''
*              then ignore record
         JE    Next

*              find next occurrence of col1 char (the delimiter)
         LA    R1,sRecData        -> First byte of string
         SLR   R0,R0
         ICM   R0,B'0011',hRecLen L'Record (including first delimiter)
         AHI   R0,-(4+1)          -4 for LLBB, -1 for record type byte

Next2    DS    0H
         CLC   cRecType,0(R1)     End delimiter found?
         JE    End2               Yes, branch

         TR    0(1,R1),sToASCII   Translate byte to ASCII
         LA    R1,1(,R1)          -> Next source byte
         BRCT  R0,Next2           ...until source is exhausted

End2     DS    0H
         LA    R0,sRecData        -> String
         SR    R1,R0              L'String
         JNP   Next               Ignore delimiter by itself

*              append remaining record
         LR    R0,R1              L'String (excluding end delimiter)
         LA    R1,sRecData        -> First byte of string
         BRAS  R14,Append
         J     Next
*            end /* Otherwise */
*          end /* select */
*        end /* while not eof */

         POP   USING

*        Close separator member
EOF      DS    0H
         CLOSE (sFile),MF=(E,sClose),MODE=31
         MVC   pPCLNext,pPCL      -> Next chunk to be printed
         J     Primed

*---------------------------------------------------------------------*
*        Error reading PDS                                            *
*---------------------------------------------------------------------*

CloseFile DS   0H
         CLOSE (sFile),MF=(E,sClose),MODE=31  Close PDS
         J     SetRC16              ...and dont come back

*---------------------------------------------------------------------*
*        Work area has been obtained and filled in...                 *
*---------------------------------------------------------------------*

Primed   DS    0H                 Work area is Primed
         L     R5,pPRAT           -> VPSSPRAT

*---------------------------------------------------------------------*
*        Print the next item in the PCL data buffer                   *
*---------------------------------------------------------------------*

*        INPUT PCL DATA BUFFER FORMAT

*             pPCL   pPCLNext     pPCLData                  pPCLMax
*              |        |            |                            |
*              v     ...v...         v                            v
*             .--------------------------------------------------.
* PCL buffer: |data to be printed...|                            |
*             '--------------------------------------------------'
*              <---- nPCLData ------>
*              <--------------------- nPCL ---------------------->

         CLC   pPCLNext,pPCLData  Anything left to print?
         JNL   SetRC4             No, release storage; dont come back

*        CLI   PRALUTYP,$PRALUT   Is this a TCP/IP printer?
*        JE    TCP                Yes, branch
         TM    PRADEVF4,$PRADLPD+$PRADSOK Is this a TCP/IP printer?
*                       $PRADLPD = TCP/IP Line Printer Daemon (LPD)
*                       $PRADSOK = TCP/IP Direct Sockets (port 9100)
         JNZ   TCP                Yes, branch

*---------------------------------------------------------------------*
*        Build PCL chunk to be sent to an SNA printer...              *
*---------------------------------------------------------------------*

*        OUTPUT PCL CHUNK BUFFER FORMAT FOR SNA

*        LINELNC (Carriage control byte which is ignored)
*         | LINELND (SNA Transparency character)
*         |  |  .---(SNA Transparency length byte)
*         V  V  V
*        .------------------------------------------------------.
*        |CC|35|LL|         ...PCL Data Chunk...        |       |
*        '------------------------------------------------------'
*        <--------------------- LINELNL ---------------->
*        <--------------------- LINELNLM ----------------------->

*        Set VPS print line flags...
         MVI   LINELNF,$LINECCP   Skip carriage control processing
*                                 Line does not have carriage control
         MVI   LINELNF2,$LINEBXL+$LINEBTU+$LINEBTB
*                       $LINEBXL  Bypass translation...
*                       $LINEBTU  Bypass standard truncation...
*                       $LINEBTB  Bypass trailing blank truncation...

*        Compute length of chunk...
         SLR   R2,R2                                           20030124
         ICM   R2,B'0011',LINELNLM  Max line length (incl. CC) 20030124
         CLC   LINELNLM,=H'258'   Bigger than max SNA trans. seq?
         JNH   NotMax             No, branch
         LHI   R2,258             Yes, limit to 1+1+1+255 (for SNA)
NotMax   DS    0H

*        Build SNA transparency escape sequence...
         MVI   LINELND,X'35'      SNA transparency character

         L     R1,pPCLData        -> Next free byte in buffer
         SL    R1,pPCLNext        -> Next chunk (=length remaining)
         AHI   R2,-3              -1 for CC
*                                 -1 for SNA transparency char
*                                 -1 for length byte
         CR    R2,R1              Print complete chunk?
         JNH   SNAChunk           Yes, branch

         LR    R2,R1              No, print residual

*        Get next chunk to be printed...
SNAChunk DS    0H
         STC   R2,LINELND+1       SNA transparency length

         LA    R0,LINELND+2       -> Target
         LR    R1,R2              L'Target = L'Source
         L     R14,pPCLNext       -> Source
         LR    R15,R2             L'Source
         MVCL  R0,R14             Copy source to target

*        Point to the next source chunk...
         L     R14,pPCLNext       -> This source chunk
         AR    R14,R2             + L'chunk printed
         ST    R14,pPCLNext       -> Next source chunk

*        Set the line length for VPS...
         AHI   R2,3               +3 for (CC, SNA esc, SNA length)
         STH   R2,LINELNL         Set line length (incl. CC)

         MVC   nRetCode,=F'0'     Print target and come back
         J     Return

*---------------------------------------------------------------------*
*        Build PCL chunk to be sent to a TCPIP printer                *
*---------------------------------------------------------------------*

*        OUTPUT PCL CHUNK BUFFER FORMAT FOR TCP

*        LINELNC (Carriage control byte which is ignored)
*         | LINELND
*         |  |
*         V  V
*        .------------------------------------------------------.
*        |CC|             ...PCL Data Chunk...          |       |
*        '------------------------------------------------------'
*        <--------------------- LINELNL ---------------->
*        <--------------------- LINELNLM ----------------------->

TCP      DS    0H
*        Set VPS print line flags...
         MVI   LINELNF,$LINECCP   Skip carriage control processing
*                                 Line does not have carriage control
         MVI   LINELNF2,$LINEBXL+$LINEBTU+$LINEBTB
*                       $LINEBXL  Bypass translation...
*                       $LINEBTU  Bypass standard truncation...
*                       $LINEBTB  Bypass trailing blank truncation...

*        Compute length of chunk...
         SLR   R2,R2                                           20030124
         ICM   R2,B'0011',LINELNLM  Max line length (incl. CC) 20030124

         L     R1,pPCLData        -> Next free byte in buffer
         SL    R1,pPCLNext        -> Next chunk (=length remaining)
         BCTR  R2,*-*             -1 for CC
         CR    R2,R1              Print complete chunk?
         JNH   TCPChunk           Yes, branch

         LR    R2,R1              No, print residual

*        Get next chunk to be printed...
TCPChunk DS    0H
         LA    R0,LINELND         -> Target
         LR    R1,R2              L'Target = L'Source
         L     R14,pPCLNext       -> Source
         LR    R15,R2             L'Source
         MVCL  R0,R14             Copy source to target

*        Point to the next source chunk...
         L     R14,pPCLNext       -> This source chunk
         AR    R14,R2             + L'chunk printed
         ST    R14,pPCLNext       -> Next source chunk

*        Set the line length for VPS...
         AHI   R2,1               +1 for CC
         STH   R2,LINELNL         Set line length (incl. CC)

         MVC   nRetCode,=F'0'     Print target and come back
         J     Return

***********************************************************************
*                                                                     *
*                         LINE-MODE PRINTERS                          *
*                                                                     *
***********************************************************************

LineMode DS    0H
         L     R10,pWorkArea      -> Workarea

         LH    R1,hSepLine        Current separator line number
         AHI   R1,1               +1
         STH   R1,hSepLine        Update separator line number

         LHI   R0,54              Maximum lines for separator
         CR    R1,R0              Current line number greater than max?
         JH    SetRC4             Yes, quit and dont return

         LHI   R2,133               INITIALIZE LINE LENGTH TO 133.
         STH   R2,LINELNL           STORE LENGTH IN LINE AREA.

         MVI   WORKLNC,$ASSP        INITIALIZE ASA CHAR TO SINGLE SPACE
         LA    R0,WORKLND           LOAD R0 W/ ADDR OF WORK LINE DATA.
         LHI   R1,132               LOAD R1 W/ LEN  OF WORK LINE DATA.
         SR    R14,R14              CLEAR R14.
         L     R15,=A(X'40000000')  WE'LL PROPAGATE SPACES.
         MVCL  R0,R14               CLEAR LINE DATA AREA.

*---------------------------------------------------------------------*
*        Determine which lines are being built                        *
*---------------------------------------------------------------------*

         CLC   hSepLine,=H'1'       Line 1?
         JNE   Not1
         MVI   cSepOffset,+11       Initialise centering offset

Not1     DS    0H
         CLC   hSepLine,=H'12'      Lines  1 - 12?
         JNH   BLK#JOB              Yes, job name

         CLC   hSepLine,=H'15'      Lines 13 - 15?
         JNH   SetRC0               Yes, blank

         CLC   hSepLine,=H'27'      Line 27?
         JNE   Not27
         MVI   cSepOffset,+11       Initialise centering offset

Not27    DS    0H
         CLC   hSepLine,=H'27'      Lines 16 - 27?
         JNH   BLK#ID               Yes, job id and class

         CLC   hSepLine,=H'30'      Lines 28 - 30?
         JNH   SetRC0               Yes, blank

         CLC   hSepLine,=H'42'      Lines 31 - 42?
         JNH   BLK#015              Yes, blank

         CLC   hSepLine,=H'44'      Lines 43 - 44?
         JNH   SetRC0               Yes, blank
         J     BLK#015              No, blank lines 45+

BLK#015  EQU   *
         CLC   hSepLine,=H'51'      Lines 43 - 51?
         JNH   SetRC0               Yes, blank line
         CLC   hSepLine,=H'52'      Line 52?
         JNH   BLK#200              Yes, print last line
         J     SetRC4               Exit and dont come back

         EJECT
*---------------------------------------------------------------------*
*        Set up block letters for Job id and Sysout class             *
*---------------------------------------------------------------------*

BLK#ID   DS    0H
         L     R10,pWorkArea        Address workarea
         MVC   sAsIs(1),sJobI       SAVE THE 1ST POSITION OF JOB ID
         MVC   sAsIs+1(5),sJobI+3   SAVE THE DIGITS OF JOB ID
         MVI   sAsIs+6,X'40'        MOVE IN ONE BLANK
         MVC   sAsIs+7(1),sRepC     SAVE THE SYSOUT CLASS
         MVC   sTrans,sAsIs         SAVE JOB ID/CLASS FOR TRANSLATION
         OC    sTrans,=8X'C0'       TURN ON 2 HIGH-ORDER BITS
         TR    sTrans,INDEXTAB-192 TRANSLATE TO INDEX VALUE
         MVI   bSlant,C'N'
         MVI   bCentre,C'Y'
         LA    R2,WORKLND           START AT 1ST PRINT POSITION.      *
         J     CHKCENTR             GO FORM THE BLOCK LETTERS.
         EJECT
*---------------------------------------------------------------------*
*        Set up block letters for job name                            *
*---------------------------------------------------------------------*

BLK#JOB  DS    0H
         CLC   hSepLine,=H'1'       IS THIS THE FIRST LINE?
         JNE   BLK#JOBA             NO, BRANCH AROUND NEXT INST
         MVI   WORKLNC,$ACH1        SKIP TO CHANNEL-1 ASA CHARACTER.

BLK#JOBA DS    0H
         MVC   sAsIs,sJobN          SAVE THE JOB NAME
         MVC   sTrans,sJobN         SAVE THE JOB NAME FOR TRANSLATION
         OC    sTrans,=8X'C0'       TURN ON 2 HIGH-ORDER BITS
         TR    sTrans,INDEXTAB-192 TRANSLATE TO INDEX VALUE

         MVI   bSlant,C'Y'
         MVI   bCentre,C'Y'
         LA    R2,WORKLND           START AT 1ST PRINT POSITION
         J     CHKCENTR             GO FORM THE BLOCK LETTERS.

*---------------------------------------------------------------
*        Check if text is to be centred
*---------------------------------------------------------------

CHKCENTR DS    0H
         CLI   bCentre,C'Y'
         JNE   CHKSLANT
         LHI   R1,7                 SET R1 TO LENGTH OF FIELD - 1

BLK#110  EQU   *
         LA    R15,sAsIs(R1)        POINT R15 TO LAST CHARACTER
         CLI   0(R15),C' '          IS THIS CHARACTER BLANK?
         JNE   BLK#115              NO, WE HAVE THE LENGTH
         BRCT  R1,BLK#110           DECREMENT R1 AND CHECK AGAIN

BLK#115  EQU   *
         AHI   R1,1                 BUMP R1 BY 1 TO GET ACTUAL # BYTES

         MHI   R1,14                MULTIPLY BY # POSITIONS IN 1 LETTER
         LHI   R15,132              PUT MAX VALUE INTO R15
         SR    R15,R1               SUBTRACT OCCUPIED SPACE
         SRL   R15,1                DIVIDE BY 2
         LA    R2,WORKLND(R15)      POINT R2 TO STARTING POSITION

*---------------------------------------------------------------
*        Check if text is to be slanted
*---------------------------------------------------------------

CHKSLANT DS    0H
         CLI   bSlant,C'Y'          Slant text?
         JNE   OFFSET0              No, branch

         SLR   R1,R1
         IC    R1,cSepOffset        R1 = Column offset to be applied
         AR    R2,R1                R2 = Start + Offset
         BCTR  R1,*-*               Decrement offset
         LTR   R1,R1                Gone negative?
         JM    OFFSET0              Yes, leave it at zero
         STC   R1,cSepOffset        No, save for next line
OFFSET0  DS    0H

*---------------------------------------------------------------------*
*        Build block letters                                          *
*---------------------------------------------------------------------*

BLK#140  EQU   *
         MVC   hCharNo,=H'0'        SET CHARACTER COUNTER TO ZERO

BLK#145  EQU   *
         LH    R15,hCharNo          PUT CHARACTER COUNTER VALUE IN R15
         LA    R3,sAsIs(R15)        POINT R3 TO APPROPRIATE CHARACTER
         MVC   cSaved(1),0(R3)      SAVE THAT CHARACTER FOR MOVES

         CLI   cSaved,C'.'          Is it a fullstop?
         JE    BLK#145A             Yes, replace with '*'
         CLI   cSaved,C','          Is it a comma?
         JNE   BLK#145B             No, branch
BLK#145A DS    0H
         MVI   cSaved,C'*'          Use '*' to make it show up
BLK#145B DS    0H
         LA    R3,sTrans(R15)       POINT R3 TO INDEX CHARACTER
         SLR   R15,R15              CLEAR R15
         ICM   R15,B'0001',0(R3)    PUT INDEX CHARACTER INTO R15
         JZ    BLK#175              IF ZERO, GO DIRECTLY TO MOVE

         BCTR  R15,*-*              MAKE IT RELATIVE TO ZERO
         MHI   R15,24               MULTIPLY BY LENGTH OF ONE ENTRY
         LH    R3,hSepLine          PUT LINE NUMBER IN R3
         BCTR  R3,*-*               SUBTRACT 1

         CLC   hSepLine,=H'13'      ARE WE WORKING ON JOB NAME?
         JL    BLK#150              YES, USE LINE NUMBER AS IS

         AHI   R3,-15               MAKE IT RELATIVE TO LINE 1
         CHI   R3,15                Are we working on 3rd row?
         JL    BLK#150              No, use line number as is
         AHI   R3,-15               Make it relative to line 1

BLK#150  EQU   *
         SLL   R3,1                 MULTIPLY BY 2
         AR    R15,R3               BUMP TO CORRECT LINE NUMBER
         LA    R15,WIDEA(R15)       POINT R15 TO APPROPRIATE BITS
         ICM   R15,B'1100',0(R15)   PUT BITS INTO R15

BLK#175  EQU   *
         LHI   R1,12                PUT WIDTH OF BLOCK LETTER IN R1

BLK#185  EQU   *
         ALR   R15,R15              ADD R15 TO ITSELF
         BRC   12,BLK#190           HIGH-ORDER BIT WAS OFF, SKIP MOVE
         MVC   0(1,R2),cSaved       MOVE IN SAVED CHARACTER

BLK#190  EQU   *
         LA    R2,1(,R2)            BUMP POINTER TO NEXT PRINT POSITION
         BRCT  R1,BLK#185           CONTINUE UNTIL LETTER IS BUILT

         LA    R2,2(,R2)            TWO SPACES BETWEEN LETTERS

         LH    R15,hCharNo          PUT CHARACTER COUNTER INTO R15
         AHI   R15,1                BUMP R15 BY 1
         STH   R15,hCharNo          PUT RESULT BACK INTO CHAR COUNTER

         CH    R15,=H'8'            HAVE WE MOVED ALL CHARACTERS?
         JL    BLK#145              NO, GO THROUGH PROCESS AGAIN

         J     SetRC0               -EXIT.

*---------------------------------------------------------------------*
*        Move in the data which is the same for start and end         *
*---------------------------------------------------------------------*

BLK#200  EQU   *
         MVI   WASTER1,C'*'
         MVC   WCLASS1,sRepC                MOVE IN SYSOUT CLASS
         MVC   WJOBID1,sJobI                MOVE IN JOB ID
         MVC   WJOBNAME,sJobN               MOVE IN JOB NAME
         MVC   WDEST,sRepD                  MOVE IN JOB DEST
         MVC   WNAME,sUsrN        User's name
         MVC   WJOBID2,sJobI                MOVE IN JOB ID
         MVC   WCLASS2,sRepC                MOVE IN SYSOUT CLASS
         MVI   WASTER2,C'*'


         CLC   nRequest,=F'0'               IS THE REQUEST FOR START?
         JNE   BLK#END                      NO, GO MOVE IN END DATA

*---------------------------------------------------------------------*
*        Move in the data which is unique to START separators         *
*---------------------------------------------------------------------*

BLK#BEG  DS    0H
         TM    SEPFLAG1,$SEPINTR            INTERRUPTED DATASET?
         JZ    BLK#212                      NO, GO MOVE IN "START"

         MVC   WSTATUS1,=CL5'CONT '         CONT INDICATOR
         MVC   WSTATUS2,WSTATUS1            CONT INDICATOR
         J     BLK#214                      GO MOVE IN OTHER INFO

BLK#212  DS    0H
         MVC   WSTATUS1,=CL5'START'         START INDICATOR
         MVC   WSTATUS2,WSTATUS1            START INDICATOR

BLK#214  DS    0H
         MVC   WDATE,sRepP
         J     SetRC0               -EXIT.

*---------------------------------------------------------------------*
*        Move in the data which is unique to END separators           *
*---------------------------------------------------------------------*

BLK#END  DS    0H
         MVC   WSTATUS1,=CL5'END'           "END" INDICATOR
         MVC   WSTATUS2,WSTATUS1            "END" INDICATOR
         MVC   WDATE,sRepP
         J     SetRC0               -EXIT.
         EJECT
*---------------------------------------------------------------------*
*        Exit from separator routine                                  *
*---------------------------------------------------------------------*

* Appropriate return code must be set:
*       00 = Print separator line that has been built and come back
*       04 = Processing complete, don't come back
*       16 = Disastrous error, EDRAIN printer, don't come back

SetRC16  DS    0H
         MVC   nRetCode,=F'16'    Disastrous error.  EDRAIN printer
         J     Release

SetRC4   DS    0H
         MVC   nRetCode,=F'4'     Dont print and dont come back
         J     Reset

SetRC0   DS    0H
         MVC   nRetCode,=F'0'     Print and come back

         CLC   LINELNL,LINELNLM   IS LINE LONGER THAN MAX ALLOWED?
         JNH   NoTrunc            NO, GO MOVE FULL LINE.
         MVC   LINELNL,LINELNLM   TRUNCATE LENGTH TO MAX ALLOWED.
NoTrunc  DS    0H

         LA    R0,LINELNC         -> Target
         SLR   R1,R1
         ICM   R1,B'0011',LINELNL L'Target
         LA    R14,WORKLINE       -> Source
         LR    R15,R1             L'Source = L'Target
         MVCL  R0,R14             Copy source to target
         J     Return

CleanUp  DS    0H                 Reset line number and exit
Reset    DS    0H
         XC    hSepLine,hSepLine  RESET SEPARATOR LINE NO.

Release  DS    0H
         L     R10,pWorkArea      -> Workarea to be released
         LTR   R10,R10              Is it zero?
         JZ    Return               Yes, dont try to release it

         L     R1,pPCL            -> PCL buffer
         LTR   R1,R1
         JZ    RelWork

         L     R0,nPCL            L'PCL buffer
         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)

RelWork  DS    0H
         STORAGE RELEASE,LENGTH=WORKAREA#,ADDR=(R10)
         XC    pWorkArea,pWorkArea  Zero workarea address
         J     Return

Return   DS    0H
         L     R2,nRetCode        SAVE RETURN CODE IN R2.
         LR    R1,R13             ADDRESS OF AREA TO RELEASE.
         L     R13,4(,R13)        ADDRESS OF CALLERS SAVEAREA.
         ST    R2,16(R13)         SET RETURN CODE.

         FREEMAIN RU,LV=SEPRDSLN,A=(1)  FREE WORK AREA.

         LM    R14,R12,12(R13)    RESTORE CALLERS REGISTERS.
         BR    R14                RETURN TO VPS.

*=========================== END OF ROUTINE ==========================*
         EJECT
***********************************************************************
**                                                                   **
** FUNCTION - Appends the specified data to the PCL buffer.          **
**            Automatically allocates the PCL buffer if it is not    **
**            already allocated.  Automatically inflates the PCL     **
**            buffer if it is not big enough to hold the new data.   **
**            Automatically prangs if it is all too much.            **
**                                                                   **
**                                                                   **
** ON ENTRY - R1 -> Data to be appended to PCL buffer                **
**            R0  = Length of data to be appended                    **
**                                                                   **
**            pPCL     pPCLNext   pPCLData                  pPCLMax  **
**             |          |          |                            |  **
**             v       ...v...       v                            v  **
**            .--------------------------------------------------.   **
**            |xxxxxxxxxxxxxxxxxxxxx|                            |   **
**            '--------------------------------------------------'   **
**             <---- nPCLData ------>                                **
**             <--------------------- nPCL ---------------------->   **
**                                                                   **
**            pPCL     -> PCL buffer                                 **
**            nPCL     = Length of PCL buffer                        **
**            pPCLMax  -> Byte after PCL buffer                      **
**            nPCLData = Length of data in PCL buffer                **
**            pPCLData -> Next free byte in PCL buffer               **
**            pPCLNext -> Next chunk to print                        **
**                                                                   **
**                                                                   **
** ON EXIT  - Data appended and pointers/lengths updated.            **
**                                                                   **
***********************************************************************

Append   DS    0H
         STM   R0,R15,nRegs

         CLC   pPCL,=A(0)           Do we have a buffer?
         JNE   AppData              Yes, branch to append to it

         XC    nPCLData,nPCLData    No, set PCL data length = 0
         LHI   R0,2048              Initial length of PCL buffer
         J     AppObt               Obtain initial buffer

*---------------------------------------------------------------------*
*        Inflate the size of the existing PCL buffer                  *
*---------------------------------------------------------------------*

AppNew   DS    0H
*        Compute length of new buffer
         L     R0,nPCL              Get current buffer length
         AR    R0,R0                Double it

*---------------------------------------------------------------------*
*        Obtain a new buffer (length specified by R0)                 *
*---------------------------------------------------------------------*

AppObt   DS    0H
         LR    R6,R0                Save length of new buffer
         STORAGE OBTAIN,LENGTH=(6),LOC=BELOW,ADDR=(1)
         LTR   R15,R15              Did it work?
         JZ    AppGot               Yes, branch
         LM    R0,R15,nRegs         No, restore registers
         J     CloseFile            ...and exit stage left

AppGot   DS    0H
         LR    R7,R1                Save address of new buffer

*        Check whether we have an old buffer to copy
         L     R4,pPCL              ->Source (old buffer)
         LTR   R4,R4                Do we have an old buffer?
         JZ    AppUpd               No, dont copy or release it

*        Copy the old buffer to the new buffer
         LR    R2,R1                ->Target (new buffer)
         L     R3,nPCL              L'Target = L'Source
         LR    R5,R3                L'Source
         MVCL  R2,R4                Copy old buffer to new buffer

*        Release the old buffer
         L     R0,nPCL
         L     R1,pPCL
         STORAGE RELEASE,LENGTH=(0),ADDR=(1)  Release old buffer

*        Update pointers
AppUpd   DS    0H
         ST    R7,pPCL              -> PCL buffer
         ST    R6,nPCL              L'PCL buffer

         AR    R7,R6                -> PCL buffer + L'PCL buffer
         ST    R7,pPCLMax           -> Byte after end of buffer

         L     R7,pPCL              -> PCL buffer
         AL    R7,nPCLData          + L'Data in the buffer
         ST    R7,pPCLData          -> Next free byte in PCL buffer

*---------------------------------------------------------------------*
*        Append data to the PCL buffer                                *
*---------------------------------------------------------------------*

AppData  DS    0H
         L     R3,nRegs+0         L'Source (R0 on entry)
         L     R2,nRegs+4         ->Source (R1 on entry)
         L     R1,pPCLData        ->Target
         AR    R1,R3              ->Target+L'Source
         C     R1,pPCLMax         Buffer too small?
         JH    AppNew             Yes, inflate it

         L     R4,nPCLData        Get L'data in buffer
         AR    R4,R3              Add L'data to be appended
         ST    R4,nPCLData        Save updated length

         L     R4,pPCLData        ->Target
         LR    R5,R3              L'Target = L'Source
         MVCL  R4,R2              Append source to PCL buffer

         ST    R4,pPCLData        ->Next free byte in PCL buffer

*---------------------------------------------------------------------*
*        Return                                                       *
*---------------------------------------------------------------------*

         LM    R0,R15,nRegs
         BR    R14

*=========================== END OF ROUTINE ==========================*
         EJECT
***********************************************************************
**                                                                   **
** FUNCTION - Convert first number found in the source field to      **
**            binary and return it in R2.  Sets the condition code   **
**            to indicate whether a number was found or not.         **
**                                                                   **
**                                                                   **
** ON ENTRY - R0  =  Length of remaining data to scan                **
**            R1  -> Start of data to scan                           **
**            R14 = Return address                                   **
**                                                                   **
** ON EXIT  - R0  =  Length of remaining data to scan                **
**            R1  -> Start of remaining data to scan                 **
**            R2  =  Binary value of first number found (if CC = 0)  **
**                =  Zero (if CC <> 0)                               **
**                                                                   **
***********************************************************************

c2b      DS    0H
         STM   R3,R5,nReg3to5

*---------------------------------------------------------------------*
*        Skip any leading non-numerics...                             *
*---------------------------------------------------------------------*

         BCTR  R1,*-*             -> Source text - 1

c2bLBL   DS    0H
         LA    R1,1(,R1)          -> Next source byte
         CLI   0(R1),C' '         End-of-data found?
         JE    c2bNBG             Yes, no number found
         CLI   0(R1),C'1'         Is digit < C'1'?
         JL    c2bSkip            Yes, skip it (includes zeros)
         CLI   0(R1),C'9'         Is digit > C'9'?
         JNH   c2bFirst           Yes, process first non-zero digit
c2bSkip  DS    0H
         BRCT  R0,c2bLBL          No, skip it...
         J     c2bNBG             ...unless all are non-numerics

c2bFirst DS    0H
         SLR   R4,R4              Count of digits found = 0
         LR    R5,R1              -> First numeric character
         J     c2bDigit

*---------------------------------------------------------------------*
*        Ensure following characters are decimal digits               *
*---------------------------------------------------------------------*

c2bNext  DS    0H
         LA    R1,1(,R1)          -> Next source byte
         CLI   0(R1),C' '         Terminating blank?
         JE    c2bDig             Yes, branch

c2bDigit DS    0H
         CLI   0(R1),C'0'         Is digit < C'0'?
         JL    c2bDig             Yes, branch
         CLI   0(R1),C'9'         Is digit > C'9'?
         JH    c2bDig             Yes, branch
         AHI   R4,1               Increment digit count
         BRCT  R0,c2bNext         Continue checking until...
         J     c2bDig             ...all characters are digits

*---------------------------------------------------------------------*
*        Convert source string to packed decimal                      *
*---------------------------------------------------------------------*

c2bDig   DS    0H
         CL    R4,=F'10'          Is it longer than 10 digits?
         JH    c2bNBG             Yes, invalid number

         BCTR  R4,*-*             -1 for EX
c2bPack  PACK  dWork,0(*-*,R5)
         EX    R4,c2bPack         Convert source to packed decimal

*---------------------------------------------------------------------*
*        Check that it is between -2147483648 and +2147483647         *
*---------------------------------------------------------------------*

c2bPos   DS    0H
         CP    dWork,=P'2147483647' Is number too positive?
         JH    c2bNBG             Yes, branch

         CVB   R2,dWork           Convert packed decimal to binary
         J     c2bOK

*---------------------------------------------------------------------*
*        Set condition code 1.  Number is invalid.  R1 = 0            *
*---------------------------------------------------------------------*

c2bNBG   DS    0H
         LM    R3,R5,nReg3to5
         SLR   R2,R2              Number = 0
         CLI   *,0                Set condition code 1
         BR    R14

*---------------------------------------------------------------------*
*        Set condition code 0.  Number is valid.    R1 = number       *
*---------------------------------------------------------------------*

c2bOK    DS    0H
         LM    R3,R5,nReg3to5
         CLI   *+1,0              Set condition code 0
         BR    R14

*=========================== END OF ROUTINE ==========================*
         EJECT
***********************************************************************
*                                                                     *
*                           L I T E R A L S                           *
*                                                                     *
***********************************************************************

         LTORG ,

         EJECT
***********************************************************************
*                                                                     *
*                          C O N S T A N T S                          *
*                                                                     *
***********************************************************************


*---------------------------------------------------------------------*
*        Skeletons to be copied to WORKAREA before use                *
*---------------------------------------------------------------------*

kVerify  RACROUTE MF=L,            Parameter list for RACROUTE         X
               REQUEST=VERIFY,                                         X
               RELEASE=2.4

         DS    0D
kFile    DCB   DDNAME=SEPAR,                                           X
               DSORG=PO,                                               X
               RECFM=VB,                                               X
               LRECL=sBlock#-4,   See below                            X
               MACRF=(R),                                              X
               BLKSIZE=sBlock#,   See below                            X
               DCBE=kDCBE,                                     20010810X
               KEYLEN=0

kDCBE    DCBE  EODAD=EOF                                       20010810

kOpen    OPEN  (kFile,INPUT),MODE=31,MF=L

kClose   CLOSE (kFile),MODE=31,MF=L

*---------------------------------------------------------------------*
*        Miscellaneous constants                                      *
*---------------------------------------------------------------------*

sBlanks  DC    CL(L'sVar)' '

*---------------------------------------------------------------------*
*        Translation tables for block letters                         *
*---------------------------------------------------------------------*

INDEXTAB DS    0D
*                C0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'00010203040506070809002800000000'   A-I .
         DC    X'000A0B0C0D0E0F101112001300000000'   J-R $
         DC    X'00001415161718191A1B002900000000'   S-Z ,
         DC    X'1C1D1E1F202122232425002627000000'   0-9 # @

WIDEA    DC    X'7FE0FFF0C030C030C030FFF0FFF0C030C030C030C030C030'
WIDEB    DC    X'FFE0FFF0C030C030C060FFC0FFC0C060C030C030FFF0FFE0'
WIDEC    DC    X'7FE0FFF0C030C000C000C000C000C000C000C030FFF07FE0'
WIDED    DC    X'FF80FFC0C060C030C030C030C030C030C030C060FFC0FF80'
WIDEE    DC    X'FFF0FFF0C000C000C000FF00FF00C000C000C000FFF0FFF0'
WIDEF    DC    X'FFF0FFF0C000C000C000FF00FF00C000C000C000C000C000'
WIDEG    DC    X'7FE0FFF0C030C000C000C000C1F0C1F0C030C030FFF07FE0'
WIDEH    DC    X'C030C030C030C030C030FFF0FFF0C030C030C030C030C030'
WIDEI    DC    X'7FE07FE0060006000600060006000600060006007FE07FE0'
WIDEJ    DC    X'3FF03FF0030003000300030003000300C300C300FF007E00'
WIDEK    DC    X'C030C060C0C0C180C300FE00FE00C300C180C0C0C060C030'
WIDEL    DC    X'C000C000C000C000C000C000C000C000C000C000FFF0FFF0'
WIDEM    DC    X'C030E070F0F0D9B0CF30C630C030C030C030C030C030C030'
WIDEN    DC    X'C030E030F030D830CC30C630C330C1B0C0F0C070C030C010'
WIDEO    DC    X'FFF0FFF0C030C030C030C030C030C030C030C030FFF0FFF0'
WIDEP    DC    X'FFE0FFF0C030C030C030FFF0FFE0C000C000C000C000C000'
WIDEQ    DC    X'7FE0FFF0C030C030C030C030C030C330C1B0C0F0FFE07FB0'
WIDER    DC    X'FFE0FFF0C030C030C030FFF0FFE0C300C180C0C0C060C030'
WIDE$    DC    X'06007FE0FFF0C630E6007FC03FE00670C630FFF07FE00600'
WIDES    DC    X'7FE0FFF0C030C000E0007FC03FE000700030C030FFF07FE0'
WIDET    DC    X'FFF0FFF00600060006000600060006000600060006000600'
WIDEU    DC    X'C030C030C030C030C030C030C030C030C030C030FFF07FE0'
WIDEV    DC    X'C030C030C030C030C030C030C030606030C019800F000600'
WIDEW    DC    X'C030C030C030C030C030C030C630CF30D9B0F0F0E070C030'
WIDEX    DC    X'C030C030606030C019800F000F00198030C06060C030C030'
WIDEY    DC    X'C030C030606030C019800F00060006000600060006000600'
WIDEZ    DC    X'FFF0FFF0006000C001801FC01FC00C00180030007FF0FFF0'
WIDE0    DC    X'3FC07FE0C0F0C1B0C330C630CC30D830F030E0307FE03FC0'
WIDE1    DC    X'06000E001E0006000600060006000600060006007FE07FE0'
WIDE2    DC    X'7FE0FFF0C0300030003000600180060018006000FFF0FFF0'
WIDE3    DC    X'7FE0FFF0C0300030003001E001E000300030C030FFF07FE0'
WIDE4    DC    X'038007800D80198031807FF0FFF001800180018001800180'
WIDE5    DC    X'FFF0FFF0C000C000C000FF80FFC0006000300030FFF0FFE0'
WIDE6    DC    X'7FE0FFF0C030C000C000FFE0FFF0C030C030C030FFF07FE0'
WIDE7    DC    X'FFF0FFE0C0C0018003000600060006000600060006000600'
WIDE8    DC    X'7FE0FFF0C030C03060603FC03FC06060C030C030FFF07FE0'
WIDE9    DC    X'7FE0FFF0C030C030C030FFF0FFF000300030C030FFF07FE0'
WIDE#    DC    X'30C030C0FFF0FFF030C030C030C030C0FFF0FFF030C030C0'
WIDE@    DC    X'3FC07FE0C030003000301E303F306330C330C3307FE03FC0'
WIDEFSTOP DC   X'000000000000000000000000000000000F000F000F000F00'
WIDECOMMA DC   X'000000000000000000000000000000000F000E000C000800'

MASK$    DC  X'402020202020206B2021204B2020' MASK FOR DOLLAR VA

*---------------------------------------------------------------------*
*        EBCDIC to ASCII translation table                            *
*---------------------------------------------------------------------*

sToASCII DS   0D
*                0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC   X'000102030405060708090A0B0C0D0E0F' 0x
         DC   X'101112131415161718191A1B1C1D1E1F' 1x
         DC   X'202122232425262728292A2B2C2D2E2F' 2x
         DC   X'303132333435363738393A3B3C3D3E3F' 3x
         DC   X'204142434445464748494A2E3C282B4F' 4x
         DC   X'2651525354555657585921242A293B5F' 5x
         DC   X'2D2F62636465666768697C2C255F3E3F' 6x
         DC   X'707172737475767778793A2340273D22' 7x
         DC   X'806162636465666768698A8B8C8D8E8F' 8x
         DC   X'906A6B6C6D6E6F7071729A9B9C9D9E9F' 9x
         DC   X'A07E737475767778797AAAABACADAEAF' Ax
         DC   X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF' Bx
         DC   X'7B414243444546474849CACBCCCDCECF' Cx
         DC   X'7D4A4B4C4D4E4F505152DADBDCDDDEDF' Dx
         DC   X'5CE1535455565758595AEAEBECEDEEEF' Ex
         DC   X'30313233343536373839FAFBFCFDFEFF' Fx
         EJECT

*---------------------------------------------------------------------*
*        VariableName to VariableValue table                          *
*---------------------------------------------------------------------*

         PRINT DATA
*              Value,Name
VARTAB   DS    0D

*              VPS fields...
         VAR   sBann,BANNER   Contains either START or END or CONT

*              Job fields...
         VAR   sJobI,JOBID    Job number (eg JOBnnnnn or STCnnnnn)
         VAR   sJobN,JOBNAME  Job name

*              Printer fields...
         VAR   sPrtM,PRTMEMB  Printer VPS definition member name
         VAR   sPrtN,PRTNAME  Printer name

*              Report fields...
         VAR   sRepC,REPCLASS Report sysout class
         VAR   sRepS,REPCDATE Report creation (spooled) date
         VAR   sRepD,REPDEST  Report destination name
         VAR   sRepP,REPPDATE Report print date

*              Userid fields...
         VAR   sUsrI,USERID   User id
         VAR   sUsrN,USERNAME User full name

*              OUTPUT card fields...
         VAR   sOut1,OUTADDR1 Address line 1
         VAR   sOut2,OUTADDR2 Address line 2
         VAR   sOut3,OUTADDR3 Address line 3
         VAR   sOut4,OUTADDR4 Address line 4
         VAR   sOutB,OUTBUILD Building
         VAR   sOutC,OUTCLASS Class
         VAR   sOutO,OUTDEPT  Department
         VAR   sOutD,OUTDEST  Destination
         VAR   sOutJ,OUTJESDS JES Dataset type (ALL,JCL,LOG or MSG)
         VAR   sOutG,OUTGROUP Output group
         VAR   sOutN,OUTNAME  Name
         VAR   sOutR,OUTROOM  Room
         VAR   sOutT,OUTTITLE Title
         VAR   sOutW,OUTWTR   Writer name                      20000211

         VAR   sFlsh,FLASH    Flash overlay name               20010720
         VAR   ,         End-of-table marker
         PRINT NODATA
         EJECT
***********************************************************************
*                                                                     *
*                            E Q U A T E S                            *
*                                                                     *
***********************************************************************

$ACH1    EQU   X'F1'                   CHANNEL-1 ASA CHARACTER.
$ANSP    EQU   X'4E'                   SUPPRESS SPACE ASA CHARACTER.
$ASSP    EQU   X'40'                   SINGLE   SPACE ASA CHARACTER.
$ADSP    EQU   X'F0'                   DOUBLE   SPACE ASA CHARACTER.
$ATSP    EQU   X'60'                   TRIPLE   SPACE ASA CHARACTER.
         EJECT
***********************************************************************
*                                                                     *
*                             D S E C T S                             *
*                                                                     *
***********************************************************************

*---------------------------------------------------------------------*
*        VariableName to CurrentValue table entry                     *
*---------------------------------------------------------------------*

VARTABD  VAR   TYPE=DSECT

*---------------------------------------------------------------------*
*        Separator work area (transient)                              *
*---------------------------------------------------------------------*

*--------> SEPRDSCT IS POINTED TO BY R13
*--------> It is obtained once at each START/END entry point
*--------> and is NOT retained across calls for each print line

SEPRDSCT DSECT
SAVEAREA DS    18F                Savearea (MUST be first)
nRetCode DS    F'0'
nRequest DS    F'0'
sAsIs    DS    CL8' '
sTrans   DS    CL8' '
hCharNo  DS    H'0'               RELATIVE CHARACTER NUMBER.
cSaved   DS    C' '               SAVED CHARACTER FOR MOVES.
bSlant   DS    C'N'               Slant? N=No, Y=Yes
bCentre  DS    C'Y'               Centre? N=No, Y=Yes

*---------------------------------------------------------------------*
*        Block letter print line                                      *
*---------------------------------------------------------------------*

WORKLINE DS    0CL133             Print line
WORKLNC  DS    CL1' '             Carriage control byte
WORKLND  DS    CL132              Print data
         ORG   WORKLND
WASTER1  DS    C'*'
WCLASS1  DS    C'A'
         DS    C' '
WSTATUS1 DS    CL5'START'         START, END or CONT
         DS    C' '
WJOBID1  DS    CL8'JOBnnnnn'      Job or STC number
         DS    C' '
WJOBNAME DS    CL8'jobname'       Job or STC number
         DS    C' '
WDEST    DS    CL8'destid'        Destination name
         DS    C' '
WNAME    DS    CL20'ANDREW J ARMSTRONG  ' User's name
         DS    C' '
         DS    CL35
         DS    C' '
WDATE    DS    C'YYYY/MM/DD HH:MM:SS DAY'
         DS    C' '
WJOBID2  DS    CL8'JOBnnnnn'      Job or STC number
         DS    C' '
WSTATUS2 DS    CL5'START'         START, END or CONT
         DS    C' '
WCLASS2  DS    C'A'
WASTER2  DS    C'*'
         ORG   ,
         DS    0D                      ALIGN ON A DOUBLEWORD BOUNDARY.
SEPRDSLN EQU   *-SEPRDSCT              LENGTH OF DSECT.

*---------------------------------------------------------------------*
*        Separator scratch pad area                                   *
*---------------------------------------------------------------------*

*        These two words may be used as a separator scratch pad area.
*        The contents will not be changed between calls to the start-
*        job routine, or calls to the end-job routine.  Upon entry to
*        either routine, BOTH words will be binary zeroes.

SEPUSER  DSECT
hSepLine   DS  H                  Current separator line no.
           DS  X                  Unused
cSepOffset DS  AL1                Offset for centred text
pWorkArea  DS  A                  -> WORKAREA (see below)

*---------------------------------------------------------------------*
*        Other VPS DSECTs                                             *
*---------------------------------------------------------------------*

         VPSSJSTA
         VPSSLINE
         VPSSPRAT
         VPSSSEPI
         VPSSSYAT
         VPSSXMAT
         VPSSORAT

         TITLE ' '
***********************************************************************
*                                                                     *
*                           W O R K A R E A                           *
*                                                                     *
***********************************************************************

*---------------------------------------------------------------------*
*        Separator work area (saved across calls)                     *
*---------------------------------------------------------------------*

*        WORKAREA IS POINTED TO BY SEPADDR
*        It is obtained once at each START/END entry point
*        and is retained across calls for each print line

WORKAREA DSECT
nRegs    DS    16F
nReg3to5 DS    3F
dWork    DS    D                  Double word work area
pPRAT    DS    A                  -> VPSSPRAT

*---------------------------------------------------------------------*
*        RACF stuff                                                   *
*---------------------------------------------------------------------*

sRACFUID DS    0CL9               Userid length/data
cRACFLen DS    CL1                Userid length prefix
sRACFUsr DS    CL8                Userid proper

pACEE    DS    A                  -> RACF ACEE built by RACROUTE

         DS    0D                 MUST ALIGN ON FULLWORD BOUNDARY5JAN93
sRACFWork DS   CL512

sVerify RACROUTE MF=L,             Parameter list for RACROUTE         X
               REQUEST=VERIFY,                                         X
               RELEASE=2.4
sVerify# EQU   *-sVerify

*---------------------------------------------------------------------*
*        System variable storage area                                 *
*---------------------------------------------------------------------*

hVarLen  DS    H             L'String in sVar
hSubBeg  DS    H             Index of first substring
hSubLen  DS    H             L'Substring

sVars    EQU   *
sBann    DS    CL05'START'
sJobI    DS    CL08'JOBnnnnn'
sJobN    DS    CL08
sPrtM    DS    CL08
sPrtN    DS    CL35'255.255.255.255' ...or hostname
sRepC    DS    CL01'A'
sRepS    DS    C'yyyy/mm/dd hh:mm:ss day'
sRepD    DS    CL08'HDPSPR1'
sRepP    DS    C'yyyy/mm/dd hh:mm:ss day'
sUsrI    DS    CL08
sUsrN    DS    CL20
sOut1    DS    CL(L'ORAADDR1)
sOut2    DS    CL(L'ORAADDR2)
sOut3    DS    CL(L'ORAADDR3)
sOut4    DS    CL(L'ORAADDR4)
sOutB    DS    CL(L'ORABLDG)
sOutC    DS    CL(L'ORACLS)
sOutO    DS    CL(L'ORADEPT)
sOutD    DS    CL(L'ORADEST)
sOutJ    DS    CL(L'ORAJESDS)
sOutG    DS    CL(L'ORAGRP)
sOutN    DS    CL(L'ORANAME)
sOutR    DS    CL(L'ORAROOM)
sOutT    DS    CL(L'ORATITLE)
sOutW    DS    CL(L'ORAWTR)                                    20000211
sFlsh    DS    CL(L'XMAFLASH)                                  20010720
sVars#   EQU   *-sVars

sVar     DS    CL80 Length is the MAXIMUM sized field in sVars

*---------------------------------------------------------------------*
*        Buffer and macros to read separator PDS member               *
*---------------------------------------------------------------------*

sMember  DS    CL8

sDECB    DS    4D

sOpen    OPEN  (sFile,INPUT),MODE=31,MF=L
sOpen#   EQU   *-sOpen

sClose   CLOSE (sFile),MODE=31,MF=L
sClose#  EQU   *-sClose

         DS    0D
sFile    DCB   DDNAME=SEPAR,                                           X
               DSORG=PO,                                               X
               RECFM=VB,                                               X
               LRECL=sBlock#-4,   See below                            X
               MACRF=(R),                                              X
               BLKSIZE=sBlock#,   See below                            X
               DCBE=kDCBE,                                     20010810X
               KEYLEN=0
sFile#   EQU   *-sFile

sDCBE    DCBE  EODAD=EOF          End-of-file routine          20010810
sDCBE#   EQU   *-sDCBE                                         20010810

pPCL     DS    A                  ->PCL buffer to be sent to printer
nPCL     DS    F                  Length of PCL buffer
pPCLData DS    A                  ->Next free byte in PCL buffer
nPCLData DS    F                  Length of data in PCL buffer
pPCLMax  DS    A                  ->Byte after end of PCL buffer
pPCLNext DS    A                  ->Next chunk to be printed

pBlockEnd DS   A                  -> Byte after end of this block

sBlock   DS    0D
hBlock   DS    H                  LL (block length)
         DS    H                  BB
sBlockData DS  XL32756
sBlock#  EQU   *-sBlock

WORKAREA# EQU  *-WORKAREA

*---------------------------------------------------------------------*
*        Map a record in the block read from disk                     *
*---------------------------------------------------------------------*

RECORD   DSECT
hRecLen  DS    H                  LL (record length)
         DS    H                  BB
cRecType DS    C                  Record type ('*','E','&','B', etc)
sRecData DS    0C                 Record data (maximum record length)

*---------------------------------------------------------------------*
*        Map the Accessor Control Element Entry                       *
*---------------------------------------------------------------------*

         IHAACEE

         END   ,
